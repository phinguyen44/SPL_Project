setwd("/Users/claudiaguenther/Documents/SPL_Project")
rm(list = ls())
# LOAD NECESSARY PACKAGES & DATA
# List all packages needed for session
neededPackages = c("dplyr", "tidyr", "ggplot2", "magrittr", "countrycode")
allPackages    = c(neededPackages %in% installed.packages()[,"Package"])
# Install packages (if not already installed)
if(!all(allPackages)) {
missingIDX = which(allPackages == FALSE)
needed     = neededPackages[missingIDX]
lapply(needed, install.packages)
}
# Load all defined packages
lapply(neededPackages, library, character.only = TRUE)
# Load dataset
load("easySHARE_rel6_0_0.rda")
dat.input = easySHARE_rel6_0_0
rm(easySHARE_rel6_0_0)
################################################################################
# ENCODE MISSING VALUES
# Organize data.frame by selecting relevant variables
dat = dat.input %>%
filter(wave == "1" & (age <= 64 & age >= 50)) %>%  # wave 1 & age filter
select(wave, country_mod,                          # dataset details
female, age, isced1997_r, ch001_, mar_stat, # demographic variables
chronic_mod, maxgrip, adla, bmi2, eurod, sphus, # health indicators
ep013_mod)                                  # labor (outcome var)
rm(dat.input)
# Encode missing values according to SHARE dataset guidelines
a = c(-2, -3, -4, -7, -9, -12, -13, -14, -15, -16)
b = c("tocheck","implausible", "tocheck", "uncoded", "notApplicable",
"dontKnow", "notAskedWave", "notAskedCountry", "noInformation",
"noDropOff")
missing.value.codes = data.frame(a,b)
# This data frame can be used to verify NA codes easily.
# But for the encoding only the numeric vector a is necessary.
# Find NA locations and declare them as such
df.decl = apply(dat, 2, function(z) {
na.loc    = which(z %in% a)
z[na.loc] = NA
return(z)
})
df = data.frame(df.decl)
# If working hours is NA, this means individuals don't work
df$ep013_mod[is.na(df$ep013_mod)] = 0
# TODO: crosscheck this with variable ep005
################################################################################
# CREATE DATA FRAMES FOR ANALYSIS AND ESTIMATION
# Get country information from "countrycode" package
country_list = c("BEL", "NLD", "FRA", "SWE", "DEU", "GRC", "ITA", "ESP", "DNK",
"AUT", "CHE")
country_data = with(countrycode_data, data.frame(iso3c, iso3n))
# Variables are cleaned, converted into human-readable naming conventions, and
# converted to dummies as described in the paper
df.out       = df %>%
dplyr::left_join(country_data, by = c("country_mod" = "iso3n")) %>%
dplyr::filter(iso3c %in% country_list) %>%
dplyr::mutate(country       = factor(iso3c),
gender        = factor(ifelse(female, "FEMALE", "MALE")),
age50_54      = age < 55,
age55_59      = age >= 55 & age < 60,
age60_64      = age >= 60,
age           = factor(floor(age)),
edu_low       = isced1997_r %in% c(0, 1),
edu_second    = isced1997_r %in% 2:4,
edu_high      = isced1997_r %in% c(5, 6),
children      = ch001_,
couple        = mar_stat %in% 1:3,
h_chronic     = chronic_mod,
h_maxgrip     = maxgrip,
h_adla        = adla > 0,
h_overweight  = bmi2 == 3,
h_obese       = bmi2 == 4,
h_badmental   = eurod > 3,
h_goodsp      = sphus < 4,
labor_ft      = ep013_mod > 32,
labor_pt      = ep013_mod < 32 & ep013_mod > 0,
labor_np      = ep013_mod == 0) %>%
dplyr::select(country, gender,              # country and gender
starts_with("age"),           # age dummy
starts_with("h_"),            # health indicators
starts_with("edu_"),          # eduction dummies
children, couple,             # demographic details
starts_with("labor_")) %>%    # labor supply outcomes
na.omit() %>%                               # remove missing values
set_rownames(NULL)                          # reset row numbering
# TODO: create a function that can read a df and print out relevant statistics
# (e.g. num rows dropped bc/ na, etc. etc, et.c). Or generalize so separate
# variables can be used. (e.g. create a standard "clean" function for working
# with the SHARE data set)
# TODO: determine threshold for "severe" and "mild" conditions (currently we
# just set it as numeric
# Create standardized variables for numeric data
standardize = function(x) {
mean = sum(x)/length(x)
std  = sd(x)
val  = (x - mean) / std
return(val)
}
# TODO: Comment in report: mention it gives same results as inbuilt function
# (scale)
# Gives a vector of integer column positions of numeric variables
idx = sapply(df.out, is.numeric)
idx = seq(1:length(idx))[idx]
# Creating separate data set with standardized numeric variables for regression,
# then reselect variables as described in paper (e.g. self-reported health is
# removed)
df.reg = df.out %>%
mutate_at(.vars = vars(idx),
.funs = standardize) %>%
mutate(labor_participation = !labor_np) %>% # invert to get labor_part rate
select(country, gender, age,
h_chronic, h_adla, h_obese, h_maxgrip,
edu_second, edu_high, children, couple,
labor_participation)
# Create a list of data frames by country and gender, to be used in regression
df.splits  = split(df.reg, f = list(df.reg$country, df.reg$gender), drop = TRUE)
# Create necessary dummary variables for regression
dummify = function(data.frame) {
data.frame = data.frame %>%
select(-country, -gender)                # remove country/gender
model      = ~ 0 + .                         # needed to remove intercept
new.df     = model.matrix(model, data.frame) # create dummies
new.df     = data.frame(new.df)
return(new.df)
}
df.splits = lapply(df.splits, dummify)
# df.out is for analysis, df.reg and df.splits are for estimation
rm(list= ls()[!(ls() %in% c("df.out", "df.splits", "df.reg"))])
rm(list= ls()[!(ls() %in% c("df.reg", "df.splits"))])
neededPackages = c("aod")
allPackages    = c(neededPackages %in% installed.packages()[,"Package"])
if(!all(allPackages)) {
missingIDX = which(allPackages == FALSE)
needed     = neededPackages[missingIDX]
lapply(needed, install.packages)
}
lapply(neededPackages, library, character.only = TRUE)
allModels = lapply(df.splits, function(z){
z = z[-z$age50] # Multicollinearity
model = glm(z$labor_participationTRUE ~., family = binomial(link = "probit"), data = z)
return(model)
})
allSummaries = lapply(allModels, summary)
wald.log = list() # Save Wald Test Output
for(i in 1:length(allModels)){
# Get Element
ModelElement = allModels[[i]]
# Specify number of coefficients: Columns - 1 (dependent Variable)
nTerms = ncol(ModelElement$data) - 1
testOutput = try(wald.test(ModelElement, terms = nTerms))
if(class(testOutput) == "try-error"){
# Display warning and investigate
msg = paste0("Wald Test failed for Model Element ", i)
warning(msg)
wald.log[[i]] = "Error"
next
} else{
wald.log[[i]] = testOutput
next
}
rm(ModelElement) # clean up
next
}
wald.bound = do.call("rbind.data.frame", wald.log)
modelNames = names(allModels)
wald.df = data.frame(modelNames, wald.bound)
install.packages("aod")
install.packages("aod")
neededPackages = c("aod")
allPackages    = c(neededPackages %in% installed.packages()[,"Package"])
if(!all(allPackages)) {
missingIDX = which(allPackages == FALSE)
needed     = neededPackages[missingIDX]
lapply(needed, install.packages)
}
lapply(neededPackages, library, character.only = TRUE)
allModels = lapply(df.splits, function(z){
z = z[-z$age50] # Multicollinearity
model = glm(z$labor_participationTRUE ~., family = binomial(link = "probit"), data = z)
return(model)
})
allSummaries = lapply(allModels, summary)
wald.log = list() # Save Wald Test Output
for(i in 1:length(allModels)){
# Get Element
ModelElement = allModels[[i]]
# Specify number of coefficients: Columns - 1 (dependent Variable)
nTerms = ncol(ModelElement$data) - 1
testOutput = try(wald.test(ModelElement, terms = nTerms))
if(class(testOutput) == "try-error"){
# Display warning and investigate
msg = paste0("Wald Test failed for Model Element ", i)
warning(msg)
wald.log[[i]] = "Error"
next
} else{
wald.log[[i]] = testOutput
next
}
rm(ModelElement) # clean up
next
}
wald.log = list() # Save Wald Test Output
for(i in 1:length(allModels)){
# Get Element
ModelElement = allModels[[i]]
# Specify the of coefficients to be tested: only health variable
health = c(16:19)
# Test only the joint significance of health variables
# TODO: select health coefficients in a more efficient manner -> some Models have less coefficients
testOutput = try(wald.test(b = coef(ModelElement), Sigma = vcov(ModelElement), Terms = health)$result)
if(class(testOutput) == "try-error"){
# Display warning and investigate
msg = paste0("Wald Test failed for Model Element ", i)
warning(msg)
wald.log[[i]] = "Error"
next
} else{
wald.log[[i]] = testOutput
next
}
rm(ModelElement) # clean up
next
}
wald.bound = t(as.data.frame(wald.log))
modelNames = names(allModels)
wald.df = data.frame(modelNames, wald.bound)
install.packages("aod")
install.packages("aod")
library(aod)
library(numDeriv)
R = matrix(nrow = 23, ncol = 23)
coef.H0 = c(16:17)
R = matrix(0, nrow = 23, ncol = 23)
for (i in min(coef.H0):max(coef.H0)){ R[i,i] = 1}
View(R)
R = matrix(0, nrow = 23, ncol = 23)
coef.H0 = c(16:19) # Coefficients to be tested
View(R)
R = matrix(0, nrow = 23, ncol = 23)
coef.H0 = c(16:19) # Coefficients to be tested
for (i in min(coef.H0):max(coef.H0)){ R[i,i] = 1}
r = rep(0, length(coef.H0))
b = allSummaries$AUT.FEMALE$coefficients
R %*% b
theta = allSummaries$AUT.FEMALE$coefficients
sigma_est = (t(allSummaries$AUT.FEMALE$df.residual)(allSummaries$AUT.FEMALE$df.residual))/length(allSummaries$AUT.FEMALE$df.residual)
sigma_est = (t(allSummaries$AUT.FEMALE$df.residual)%*%
(allSummaries$AUT.FEMALE$df.residual))/ length(allSummaries$AUT.FEMALE$df.residual)
View(sigma_est)
sigma_est = ((allSummaries$AUT.FEMALE$df.residual)%*%
t(allSummaries$AUT.FEMALE$df.residual))/ length(allSummaries$AUT.FEMALE$df.residual)
View(sigma_est)
(allSummaries$AUT.FEMALE$df.residual)%*%
t(allSummaries$AUT.FEMALE$df.residual)
t(allSummaries$AUT.FEMALE$df.residual)%*%
(allSummaries$AUT.FEMALE$df.residual)
allSummaries$AUT.FEMALE$df.residual
t(allSummaries$AUT.FEMALE$dispersion)%*%
(allSummaries$AUT.FEMALE$df.residual)
allSummaries$AUT.FEMALE
allSummaries$AUT.FEMALE$cov.unscaled
X = allSummaries$AUT.FEMALE$data
X = allModels$AUT.FEMALE$data
XX = t(X) %*% X
X = allModels$AUT.FEMALE$data
XX = t(X) %*% X
X = as.matrix(allModels$AUT.FEMALE$data)
XX = t(X) %*% X
View(XX)
XX_inv = solve(t(X) %*% X)
View(XX_inv)
View(XX_inv)
allSummaries$AUT.FEMALE
sigma_est = ((allSummaries$AUT.FEMALE$coefficients[,2])%*%
t(allSummaries$AUT.FEMALE$coefficients[,2]))/ length(allSummaries$AUT.FEMALE$coefficients[,2])
sigma_est %*% XX_inv = Var
Var.theta = sigma_est %*% XX_inv
View(Var.theta)
allSummaries$AUT.FEMALE$coefficients[,2]
length(allSummaries$AUT.FEMALE$coefficients[,2]
)
