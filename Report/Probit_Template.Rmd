---
title: "Untitled"
header-includes:
  - \usepackage{float}
output: pdf_document
---

```{r setup, eval = TRUE, echo = FALSE, include = FALSE}

wd = paste0(Sys.getenv("USERPROFILE"), "/splrepo/SPL_Project")
knitr::opts_knit$set(root.dir = wd)

#source("SummaryStatistics.R")
#source("C:/Users/Julian/splrepo/SPL_Project/Scripts/SummaryStatistics.R")
#source("C:/Users/Julian/splrepo/SPL_Project/Scripts/ProbitRegression.R")
#source("./Scripts/SummaryStatistics.R")

options(xtable.comment = FALSE,
        xtable.table.placement="H")

```

```{r, eval = TRUE, echo = FALSE, include = FALSE, cache = TRUE}
source("Scripts/SummaryStatistics.R")
source("Scripts/ProbitRegression.R")
```

8 pages per person


# Crossectional Probit Regression

## Theory and Design 

### Intro

Probit models allow for the estimation of binary, random response variables, for which their distribution is binomial. 
Probit and Logit models mitigate problems that would occur in case a (linear) regression would be used for a similar task. In this case, the range of the response variable would not be restricted to the interval (0,1). Consequently, as probabilities are commonly defined on this space, non-interpretable probability estimations would be delivered. Elaborate: Heteroscedasticity problems are averted. 
The estimated coefficients are subject to a Wald Test on joint significance. 

The model formula holds under the assumption that $\epsilon \sim N(0,1)$


$$
P(Y = 1 | X = x) = \Phi (x \beta)'
$$
###Show CDF

### Marginal Effects
The marginal effect of $x_j$ on $P(Y = 1 | X = x)$ is defined as the effect of a ceteris paribus change of $x_j$ on the conditional probability that the response variable Y is realized as one.
In case of a probit model, the marginal effect of $x_j$ on $P(Y = 1 | X = x)$ is dependent on x.





## Implementation

'df.splits' is obtained using the 'by' function. A list is returned, that seperates the cleaned data frame by country and gender.
This structure is helpful throughout the following sections, as it enables to build a series of concatenated 'lapply' functions. This function invokes a c-loop that iterates over each list element. As lapply takes a list as an input and returns a list, too, it preserves the initial structure. First, it is used to create a probit model for each subset within the list. One variable, that is highly correlated with other regressors, is excluded due to multicollinearity. 

```{r, eval = FALSE}

# Probit for each country and gender 
allModels = lapply(df.splits, function(z){
  
  z     = z[-z$age50] # Multicollinearity
  model = glm(z$labor_participationTRUE ~., family = binomial(link = "probit"), data = z)
  
  return(model)
})

# Return summaries
allSummaries = lapply(allModels, summary)
```



The loop below is a robust way to apply the wald test for the dataset subsetted by country and gender and utilises only health-related variables. A log list is created, that tracks failure of applying the wald test on joint significance of the selected variables. 'Try' ensures continuation of the loop despite possible errors. In case an error occurs, the class of 'testOutput' will be 'try-error' and consequently logged into named list. Since it preserves the structure as specified in the introduction, results can be easily transformed and named. This setup has proven to be useful for debugging our test as well as finding out that some health variables are completely missing for certain subgroups, leading to selective failure of the test. 


```{r, eval = FALSE}

# Wald Test for all models
wald.log = list() # Save Wald Test Output

for(i in 1:length(allSummaries)){
  
  # Get Element
  SummaryElement = allSummaries[[i]]
  
  # Specify the of coefficients to be tested: only health variables
  health = c(16:19)
  
  # Test only the joint significance of health variables
  testOutput = try(joint.wald.test(allSummaries[[i]], 0.95, health))
  
  if(class(testOutput) == "try-error"){
   
    msg = paste0("Wald Test failed for Model Element ", i)
    warning(msg)
    
    wald.log[[i]] = "Error"
    
  } else{
    wald.log[[i]] = testOutput
  }

  rm(SummaryElement) # clean up
}

wald.bound = as.data.frame(wald.log)
colnames(wald.bound) = names(allModels)

```


Furthermore, the application of the wald test can easily be substitued.

```{r, eval = FALSE}
    testOutput = try(wald.test(b = coef(ModelElement), 
                               Sigma = vcov(ModelElement), Terms = health)$result)
```

In line with the proposed concatenated 'lapply' structure, the probability of employment can be predicted for each subset. Marginal effects are calculated using 'probitmfx', which firstly recalculates a probit model. 

```{r, eval = FALSE, warning = FALSE}
# Calculate employment probability

empl.prob = function(model){
    
    # Calculate average person per country & gender 
        X                   = model$data
        X_mean              = data.frame(t(apply(X, 2, mean)))
        
    # Predict probability of being employed of average person
        empl.probability    = predict(object = model, newdata =  X_mean, type = "response")
        return(empl.probability)
}

empl.Models = lapply(allModels, empl.prob)
 

# Calculate marginal effects and standard errors

# Same structure as before, but must calculate model again. 
mfx.Models = lapply(df.splits, function(z){
    
    z = z[-z$age50] # Multicollinearity
    
    res = probitmfx(z$labor_participationTRUE ~.,atmean = TRUE,  data = z)
    
    return(res)
    
})




```


## Empirical Results
By means of the presented model, it is evaluated how labor force participation behavior of individuals aged 50-64 is influenced by different health indicators across 11 European countries.

The original paper, written by Kalwij and Vermeulen, summarizes the results as follows:   
- The influence of health (as captured by the indicators) on labor force participation differs among individuals and across countries   
- Health improvements are associated with higher labor force participation rates  
- Decreasing health explains decreasing labor force participation of the elderly in Europe  

These main results are validated by the analysis.


```{r, eval = TRUE, results = 'asis', echo = FALSE, message = FALSE, warning = FALSE}

library("xtable", quietly = TRUE)
xtable::xtable( allSummaries[[1]])

xtable::xtable(mfx.Models[[1]]$fit)

```

\pagebreak
\newpage


### Counterfactual



# Multidisciplinary and crossnational summary statistics

sources ReadAndClean and uses 'df.out', a data frame containing variables for calculating summary statistics.

## Theory and Design
Health Variables: age(groups 50-54, 55-59, 60-64), chronic disease, maximum grip, overweight, obesity...
Labor Variables: Education level, children, labor force participation, weekly hours / time
Group by: Country, gender

## Implementation

- expand grid between country, gender and age groups and store in list
- main functions: group.share, labor, format (html table)


```{r, eval = FALSE}
# Function for calculation group shares per country
group.share = function(df, y, agg.country = TRUE) {
    if (agg.country) {
        final = tapply(df[[y]], df$country, function(x) {
            val = sum(x)/length(x)
            return(val)
        })
    } else { # return total if country-level aggregation not specified
        final = sum(df[[y]])/length(df[[y]])
    }
    return(final)
}

# Function for calculating labor participation rate per country / gender / age
labor = function(df, .country, .gender, .age) {
    dataset = df %>% 
        filter(country == .country & gender == .gender & get(.age) == TRUE)
    denom = nrow(dataset)
    numer = with(dataset, sum(labor_ft | labor_pt))
    perc  = round(numer/denom, 4)
    
    return(perc)
}

```

args.list contains three sub-lists divided in countries ('c'), gender ('g') and age ('a'). The list is passed as an argument to 'labor', which are simulatenously iterated over the sub-lists in parallel using 'pmap'.

```{r, eval = FALSE}

# use expand.grid to get all combinations of country / gender / age
agegroups = names(df.out[, 4:6])
args      = with(df.out, 
                 expand.grid(levels(country), levels(gender), agegroups, 
                             stringsAsFactors = FALSE))
args.list = list(c = as.vector(t(args[1])), 
                 g = as.vector(t(args[2])), 
                 a = as.vector(t(args[3])))

# Map over multiple arguments
output   = pmap(args.list, function(c, g, a) labor(df.out, c, g, a))
output.v = do.call("c", output)

labor.part.share    = cbind(args, output.v)
labor.part.share.df = spread(labor.part.share, Var3, output.v) %>% 
    arrange(desc(Var2)) %>% 
    set_colnames(c("Country", "Gender", 
                   paste0("Age ", rep(c("50-54", "55-59", "60-64")))))
```

The results can be easily bound into a data frame and arranged using 'dplyr'. The resulting data frame is depicted using formatter.

Subsetting presented data frame by gender...

```{r, eval = FALSE}

# Get gender specific tables
labor.part.m = labor.part.share.df %>% 
    filter(Gender == "MALE") %>% 
    set_rownames(levels(df.out$country)) %>% 
    dplyr::select(-Gender, -Country)
labor.part.f = labor.part.share.df %>% 
    filter(Gender == "FEMALE") %>% 
    set_rownames(levels(df.out$country)) %>% 
    dplyr::select(-Gender, -Country)

# Labor supply choice tables
df.female = df.out %>% filter(gender == "FEMALE")
df.male   = df.out %>% filter(gender == "MALE")
vars      = names(df.out)[grep("labor", names(df.out))][3:1] # invert

labor.supply.f    = lapply(vars, function(x) group.share(df.female, x, 1))
labor.supply.f.df = do.call(cbind.data.frame, labor.supply.f) %>% 
    set_colnames(c("Nonparticipation", "Half time", "Full time"))

labor.supply.m    = lapply(vars, function(x) group.share(df.male, x, 1))
labor.supply.m.df = do.call(cbind.data.frame, labor.supply.m) %>% 
    set_colnames(c("Nonparticipation", "Half time", "Full time"))

```


```{r, eval = FALSE}
# VISUALIZE SUMMARY STATISTICS IN TABLES

# set formats
format.settings = function(x) {
    if (max(x) > 1 & max(x) < 100) {
        # show above mean entries for non-percentage variables in bold
        formatter(
            "span",
            style = i ~ style("font-weight" = ifelse(i > mean(i), "bold", NA))
        )
    } else if (max(x) <= 1) {
        # apply conditional formatting to percentage variables by coloring
        color_tile("white", "lightblue")
    } else {
        # Leave number of observations unformatted
        formatter("span", style = NA)
    }
}

# Create a summary statistics table with conditional formatting
sum.stats.out = function(DF) {
    # create an ouput table based on row-specific criteria
    formattable(DF, lapply(DF, format.settings), 
                options(digits = 3, format = "d"),
                align = "c")
}
```


## Empirical Results

<!-- ```{r, eval = TRUE, results = 'asis', warning = FALSE, comment = FALSE, message = FALSE} -->

<!-- #source("C:/Users/Julian/splrepo/SPL_Project/Scripts/SummaryStatistics.R") -->
<!-- source("Scripts/SummaryStatistics.R") -->
<!-- library("xtable") -->

<!-- print(xtable(sum.stats.tot)) -->

<!-- ``` -->

Import Formattable Table


![Overview in Formattable](C:/Users/Julian/splrepo/SPL_Project/Output/DF6.png)


Summary statistic tables of health characteristics of the elderly
contains functions that calculate labor participation rates and type of labor chosen by gender and country
usage of pmap and purr package to loop over groupings
tables in html format
